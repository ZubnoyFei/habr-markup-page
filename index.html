<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Долой указатели</title>
</head>
<body>
<nav><a href="guardian.html">The guardian article</a></nav>
<h1>Долой указатели</h1>
<p>Несколько лет назад среди C++ блоггеров завирусилась первоапрельская шутка о том, что C++ задепрекейтил указатели
    (например, Fluent C++ — в C++ больше не будет указателей). Что ж, поскольку C++ почти никогда ничего не депрекейтит,
    это была полная умора. Однако действительно ли нам до сих пор так необходимы указатели? Именно этот вопрос я и хочу
    осветить в сегодняшней статье.</p>
<h2>О чем говорят указатели</h2>
<p>В C++ указатель сигнализирует о том, что параметр может не иметь значения. Всякий раз, когда функция получает
    указатель, мы должны реализовать в ее теле проверку, является ли параметр <code>nullptr</code>. К сожалению, я
    постоянно вижу
    код, в котором этой проверкой пренебрегают. Никакая документация и комментарии типа <i>“valid non-null object is
        required”</i> не избавляют нас от необходимости совершать эту проверку.</p>
<p>Я также видел случаи, когда проверка на <code>nullptr</code> в функции была опущена попросту потому что было сложно
    решить, что
    делать в случае nullptr. Например, когда <code>nullptr</code> получает функция, которая возвращает <code>void</code>.
</p>
<p>Но самое главное, что с этой проверкой мы неминуемо получаем дополнительные накладные расходы. Компилятор, по крайней
    насколько мне известно, не способен оптимизировать такую проверку даже в небольшой программе. Мы поговорим об этом
    подробнее чуть позже.</p>
<h2>Используйте ссылки вместо указателей</h2>
<p>Как только мы переходим на ссылки, необходимость проверки и бесконечные комментарии канут в Лету. В отличие от
    указателя, ссылка говорит нам, что на данном этапе <i>требуется валидный</i> объект.</p>
<p>Самый простой подход — по-прежнему получать указатели на границах API, если, например, у нас нет возможности изменить
    API. Но затем, в теле функции первым делом выполнять проверку на</p>
<pre> <code>nullptr </code></pre>
<p>и делать</p>
<pre><code>return</code></pre>
,
<p>если указатель</p>
<pre><code>null</code></pre>
. <p>Если
    он валидный, разыменовывать указатель и сохранять в ссылке.</p>
<pre><code>bool DoSomeStuff(int* data)
    {
    if(nullptr == data) { return false; }

    int& refData = *data;

    return HandleData(refData);
    }</code></pre>

<p>Таким образом, у нас хотя бы есть возможность сделать наш код и внутреннее API чуть-чуть опрятнее. Возможно, в
    следующем релизе мы сможем наводить порядок и в общедоступном API.</p>
<h2>Постойте, мне нужен опциональный параметр</h2>

<p>Хорошо, допустим, мы изменим все указатели на ссылки. Но что, если нам нужен параметр, который можно не предоставлять
    (maybe parameter)? Ничего не приходит на ум? Именно, опциональность! В этом случае C++17 предоставляет
    нам</p>
<pre> <code>std::optional</code></pre>
. <p>Поэтому, пожалуйста, перестаньте злоупотреблять указателями, когда хотите указать, что
    параметр
    является необязательным. Не нужно преобразовывать</p>
<pre><code>int</code></pre>
в <code>int*</code>
<p>только для того, чтобы для
    сравнения было доступно
    значение</p>
<pre><code>nullptr.</code></pre>
<pre><code>bool DoSomeStuff(std::optional
    data)
    {
    if(data.has_value()) { return HandleData(data.value()); }

    return false;
    }
</code></pre>
<p>Тип данных </p>
<pre><code>std::optional</code></pre>
<p>подходит для этих целей гораздо лучше, чем указатели. Такие функции, как</p>
<pre><code>get_value_or</code></pre>
,
<p>избавляют нас от необходимости добавления</p>
<pre><code>if</code></pre>
, <p>который будет устанавливать либо переданное значение,
    либо значение по
    умолчанию.</p>
<p>
    Хорошо, а что на счет массивов? Допустим, мы хотим передать в функцию массив — здесь мы не можем использовать
    ссылки, за исключением тех случаев, когда мы делаем это через шаблон. О, и, пожалуйста, не вспоминайте о </p>
<pre><code>std::array</code></pre>
,
<p> потому что я хочу, чтобы эту функцию можно было вызывать с различными размерами массивов. Похоже здесь нам уж точно
    не обойтись без указателей!
</p>
<pre><code>
    void IWantPointers(const char* data, const size_t length)
    {
    for(int i = 0; i &lt;length; ++i) { std::cout &lt; data[i]; }
    }

    void Use()
    {
    char data[]{"Hello, Pointers\n"};

    IWantPointers(data, sizeof(data));
    }
</code></pre>
<h2>span и string_view спешат на помощь</h2>
<p>А вот и нет. По крайней мере, нам не нужны указатели в API функции. C++20 предоставляет нам</p>
<pre> <code>std::span</code></pre>
<p> для случаев,
    когда мы хотим передать массив или непрерывный контейнер (в этом примере мы также можем использовать</p>
<pre> <code>std::string_view</code></pre>
<p> из C++17). Преимущество</p>
<pre> <code>std::span</code></pre>
<p>заключается в том, что он содержит
    информацию о количестве
    элементов данных. Таким образом, нам не нужен дополнительный параметр под размер массива и нужно на порядок меньше
    sizeof.</p>
<pre><code>
    void IWantPointers(std::span data)
    {
    for(const auto& c : data) { std::cout &lt; c; }
    }

    void Use()
    {
    char data[]{"Hello, Pointers\n"};

    IWantPointers(data);
    }
</code></pre>
<p>Думаю, сейчас мы находимся на этапе, когда можно сказать, что у нас практически нет необходимости задействовать
    указатели в API верхнего уровня. С такими вспомогательными типами, как</p> <pre><code>std::optional</code></pre> <p> и</p>
<pre>    <code>std::span</code>,</pre> <p>наша жизнь стала
    намного лучше. И да, указатели по-прежнему существуют в C++, и что бы я здесь не говорил, их право на существование
    неоспоримо. К примеру,</p> <pre><code>std::span</code></pre> <p>принимает и возвращает указатель.</p>

<h2>Почему меня это так волнует?</h2>

<p>Ну, мне просто нравятся чистые и выразительные API. Что мне еще нравится, так это эффективный код. Взгляните на
    следующий пример в <a href="https://godbolt.org/z/T6qq5q3Tb">Compiler Explorer</a> и убедитесь сами. Мы видим
    программу целиком, включая </p> <pre><code>main</code></pre>. <p>Функции</p> <pre><code>Fun</code></pre>,
    <p>которая принимает указатель и проверяет на</p> <pre><code>nullptr</code></pre>, <p>потребовалось 7 инструкций при -O3. Версии без
    проверки, как и
    версии со ссылкой, потребовалось всего 3 инструкции. И это учитывая, что компилятор видит всю программу целиком!
    Самое интересное — это Opt. Здесь я использую</p> <pre><code>std::optional</code></pre><p> в связке с</p> <pre><code>get_value_or</code>.</pre> <p>То
    есть происходит проверка
    значения. Однако и Clang, и GCC удается скомпилировать эту функцию в 6 строк ассемблерного кода. Неплохо, правда?
    Здесь отсутствует библиотечная часть, поэтому мы еще и получаем дополнительные накладные расходы за сам
    optional.</p>

<h2>Так нужны ли нам указатели?</h2>

<p>
    Что ж, надеюсь, я показал вам, что мы, по крайней мере, нуждаемся в них реже, чем раньше. Указатели по-прежнему
    являются важной частью C++, но во многих местах мы можем использовать более подходящие типы данных.
</p>
<hr>


<p>Идея модульного тестирования прочно укрепилась среди лучших практик по разработке ПО. Во многих языках это выражено в
    наличии специальных инструментов, которые могут поставляться в составе стандартной библиотеки. Но в языке С++
    ситуация иная — имеется несколько популярных сторонних библиотек, с помощью которых пишутся модельные тесты. Одна из
    таких библиотек называется GoogleTest. Приглашаем на открытое занятие, на котором мы рассмотрим, как выглядит
    использование этой библиотеки для тестирования C++ кода.</p>

<p>The article was taken from the <a href="https://habr.com/ru/company/otus/blog/669532/">Habr</a></p>
</body>
</html>